#!/bin/bash

# Some convenient bash settings.

NextInfo2() { printf "==> %s" "$1" >&2 ; }  # shows info about the next operation (to stderr)

SettingsCommon()
{
    _TUTTU_SOVELLUSTEN_POLKU=/usr/bin

    [ $_COMMON_SETTINGS_VERBOSE = yes ] && echo "==> $FUNCNAME" >&2
    case "$-" in
        *i*)
            # history commands with arrow keys (on an interactive shell)
            bind '"\e[A":history-search-backward'      # up arrow
            bind '"\e[B":history-search-forward'       # down arrow

            bind 'set show-all-if-ambiguous on'        # complete with single TAB
            bind 'set mark-symlinked-directories on'   # complete directory symlinks with slash
            ;;
    esac
    shopt -s autocd

    EDITOR=emacs
    PAGER=less

    # Set in local ~/.bashrc:
    # ROOTDIR_EOS
    # ROOTDIR_MAN


    #############################################################
    # functions
    #############################################################

    Alias()
    {
        local name="$1"
        local def="$2"
        local force="$3"   # optional, values: "yes" "no" "", "" means "yes"
        local alias="builtin alias"

        [ "$force" = "" ] && force=yes

        if [ -n "$name" ] ; then
            if [ -n "$def" ] ; then
                if [ "$force" = "yes" ] ; then
                    $alias "$name"="$def"    # assign alias only if name is "free"
                    return
                fi
                local defold=$(LANG=C type "$name" 2>/dev/null | head -n1)
                if [ -z "$defold" ] ; then
                    $alias "$name"="$def"    # assign alias only if name is "free"
                    return
                fi
                [ $_COMMON_SETTINGS_VERBOSE_ALIAS = yes ] && echo "Warning: $FUNCNAME: Overriding old definition: '$defold'." >&2
            else
                $alias "$name"
            fi
        else
            $alias
        fi
    }
    AliasIf() {
        # make alias only if the app is available
        if type "$1" &>/dev/null ; then
            shift
            Alias "$@"
        else
            [ $_COMMON_SETTINGS_VERBOSE_ALIAS = yes ] && echo "==> $FUNCNAME: sorry, program '$1' not found" >&2
        fi
    }
    Unalias() { unalias "$1" 2>/dev/null ; }

    WaitForConnection() {     # wait at most given seconds (or 10), then return 0=connection OK or 1=connection fail
        local seconds="$1"
        [ -n "$seconds" ] || seconds=10
        local ix
        for ix in $(seq $seconds) ; do
            eos-connection-checker && { echo " done." >&2 ; return 0 ; }
            printf "." >&2
            sleep 1
        done
        return 1
    }

    doc2html() {
        local in=""
        local out=""
        local overwrite=no

        while [ -n "$1" ] ; do
            case "$1" in
                -f | --force)
                    overwrite=yes
                    ;;
                -*)
                    ;;
                *)
                    in="$1"
                    out="${in%.*}".html
                    ;;
            esac
            shift
        done

        if [ -z "$in" ] ; then
            echo "error: input file needed" >&2
            return 1
        fi
        if [ "$in" = "$out" ] ; then
            echo "error: will not convert '$in' to '$out'" >&2
            return 1
        fi
        if [ -e "$out" ] && [ "$overwrite" != "yes" ] ; then
            echo "error: '$out' already exists (use option '--force' to overwrite)" >&2
            return 1
        fi

        case "$in" in
            *.md | *.MD)
                pandoc -f gfm -s -o "$out" "$in"
                ;;
            *)
                pandoc -s -o "$out" "$in"
                ;;
        esac
    }

    arch-audit() {
        local header="PACKAGE NAME|SEVERITY|TYPE"
        local underline="${header//[A-Z ]/\~}"
        {
            printf "%s\n%s\n" "$header" "$underline"
            $_TUTTU_SOVELLUSTEN_POLKU/arch-audit -f '%n|%s|%t' "$@" # | tr '[:upper:]' '[:lower:]'
        } | column -t -s'|'
    }

    kb() {   # knowledge base
        case "$1" in
            risks) arch-audit ;;
            *) cat <<EOF
Usage: $FUNCNAME parameters
Parameters:
   risks        Shows security risks in packages.
EOF
               ;;
        esac
    }

    sou() {                            # allow parameters to ~/.bashrc
        while true ; do
            case "$1" in
                *) break ;;
            esac
        done
        # NextInfo2 "Source ~/.bashrc ..."
        source ~/.bashrc "$@"
    }

    sudofuncs() {
        local tmpfile=$(mktemp)
        local name
        for name in "$@" ; do
            if [ -x $_TUTTU_SOVELLUSTEN_POLKU/$name ] ; then
                echo "$name() { sudo $_TUTTU_SOVELLUSTEN_POLKU/$name \"\$@\" ; }" >> $tmpfile
            fi
        done
        source $tmpfile
        rm -f $tmpfile
    }

    pkgdiffs-source-installed() {
        _echo2()   { echo   "$@" >&2 ; }
        _printf2() { printf "$@" >&2 ; }

        local pkg="$1"
        local data=$(expac -l "\n" -Q %F "$pkg")        # local data=$(pacman -Flq "$pkg")
        local file
        local local

        data=$(echo "$data" | grep -v "/$" | sed 's|^|/|')

        for file in $data ; do
            local="${file##*/}"
            _printf2 "%-40s: " "$local"
            if [ ! -e "$file" ] ; then
                _echo2 "file '$file' not found"
            elif [ ! -e "$local" ] ; then
                _echo2 "file '$local' not found"
            else
                case "$file" in
                    */bash-completion/*)
                        local=("$local".*completion)
                        if [ -e "$local" ] ; then
                            if diff "$file" "$local" &> /dev/null ; then
                                _echo2 OK
                            else
                                _echo2 DIFFS
                                /bin/meld "$file" "$local"
                            fi
                        else
                            _echo2 "didn't find local file for '$file'"
                        fi
                        ;;
                    *)
                        if diff "$file" "${file##*/}" &> /dev/null ; then
                            _echo2 OK
                        else
                            _echo2 DIFFS
                            /bin/meld "$file" "${file##*/}"
                        fi
                        ;;
                esac
            fi
        done
    }

    Unalias type
    type() {
        # without parameters, show all aliases and functions
        case "$1" in
            "") { alias && declare -F ; } | less ;;
            *) builtin type -a "$@" ;;
        esac
    }

    # Functions to modify variables like PATH

    VarAddFirst() {                               # adds $2 to the beginning of $1
        local -n _VAR="$1"
        local -r val="$2"

        if [ -n "$_VAR" ] ; then
            if [ -n "$val" ] ; then
                case "$_VAR" in
                    *":$val:"* | "$val:"* | *":$val" | "$val") ;;  # middle start end only
                    *) _VAR="$val:$_VAR" ;;
                esac
            fi
        else
            _VAR="$val"
        fi
    }
    VarAddLast() {                                # adds $2 to the end of $1
        local -n _VAR="$1"
        local -r val="$2"

        if [ -n "$_VAR" ] ; then
            if [ -n "$val" ] ; then
                case "$_VAR" in
                    *":$val:"* | "$val:"* | *":$val" | "$val") ;;  # middle start end only
                    *) _VAR="$_VAR:$val" ;;
                esac
            fi
        else
            _VAR="$val"
        fi
    }
    VarRemoveFirst() {                            # remove first item from $1
        local -n _VAR="$1"
        _VAR=${_VAR#*:}
    }
    VarRemoveLast() {                             # remove last item from $1
        local -n _VAR="$1"
        _VAR=${_VAR%:*}
    }
    VarRemoveAll() {                              # remove all occurrences of $2 in $1
        local -n _VAR="$1"
        _VAR=${_VAR//$1/}    # remove all occurrences of $2
        _VAR=${_VAR//::/:}   # remove all ::
        _VAR=${_VAR#:}       # remove prefix :
        _VAR=${_VAR%:}       # remove suffix :
    }

    lsd()   { find . -type d -exec ls -ld {} \; ; }

    drw()   {
        # shellcheck disable=SC2010
        ls -l "$@" | grep rw
    }

    lp()  { l  "$@" | less -F ; }   # show long listing but no hidden dotfiles except "."
    llp() { ll "$@" | less -F ; }   # show long listing of all except ".."

    lsblk() {
        local width=300
        local lsblk="$_TUTTU_SOVELLUSTEN_POLKU/lsblk -w$width"

        if [ -z "$1" ] ; then
            $lsblk -f -o+SIZE
        else
            $lsblk "$@"
        fi
    }

    BannerLine() {
        local len="$1"
        local str="$2"
        local newlines="$3"                      # ^ = newline to head, $ = newline to tail (~like in grep)

        if [ -z "$len" ] ; then
            len=$((COLUMNS / 2))
        elif [ -n "$(echo "$len" | tr -d '[0-9]')" ] ; then
            echo "$FUNCNAME: first parameter is not a number" >&2
            return 1
        fi
        case "$str" in
            "" | default) str="=" ;;
        esac

        case "$newlines" in
            "^" | "^$") echo "" ;;
        esac
        printf "%.0s$str" $(seq $len)
        case "$newlines" in
            "^$" | "$" | "") echo "" ;;
        esac
    }
    BannerLine2() { BannerLine "$@" >&2 ; }

    _AdHocChecks_() {
        _DailyCheck_() {
            _SimpleUpdateCheck() {
                return    # 'checkupdates' may cause problems...

                NextInfo2 "Checking updates ... "
                local updates
                updates=$(checkupdates)
                case "$?" in
                    2)  echo "none." >&2
                        ;;
                    0)  echo "done:" >&2
                        local header="Name|vNow|vNew|Description"                                # header item names
                        local header_ul=$(echo "$header" | sed 's/[^|]/~/g')                     # underlining the above
                        local _line

                        updates=$(echo "$updates" | sed 's/ -> / /' | tr ' ' '|')                # remove every " ->" and change every ' ' to '|'
                        updates=$(
                            echo "$updates" | \
                                while read _line ; do
                                    echo "$_line" | sed "s/$/|$(expac -Q %d ${_line%%|*})/"      # append description to each line
                                done
                               )
                        updates="$(echo "$header"; echo "$header_ul"; echo "$updates")"          # add header
                        updates=$(echo "$updates" | column -t -s'|')                             # 'column' may change longest line length...
                        local maxlen=$(echo "$updates" | wc -L)                                  # find longest line length (for bannerline)
                        BannerLine $maxlen
                        echo "$updates"
                        BannerLine $maxlen
                        ;;
                esac
            }
            local daynr=$(date +%j)
            local daynrfile=$HOME/.daynr

            if [ "$daynr" != "$(cat $daynrfile 2>/dev/null)" ] ; then
                echo "$daynr" > $daynrfile
                _SimpleUpdateCheck | sed 's|^|    |'
            fi
        }
        _CheckAlways_() {
            if [ -z "$BASH_SETTINGS_FILE" ] ; then
                echo "warning: variable BASH_SETTINGS_FILE not set!" >&2
            fi
            if [ -x /usr/local/bin/pacman ] ; then
                echo "$BASH_SETTINGS_FILE:$FUNCNAME: warning: executable /usr/local/bin/pacman exists!" >&2
            fi
        }

        _CheckAlways_            # check always when terminal is initialized
        _DailyCheck_             # check once a day, when the first terminal is launched
    }
    _AdHocChecks_

    eos_icon_path() {
        # on success, echo full icon path and return 0
        # on failure, return 1

        local -r type="$1"
        local -r name="$2"
        local icon family

        case "$type" in
            actions|animations|apps|categories|devices|emblems|emotes|filesystems|intl|mimetypes|places|status|stock) ;;
            *) return 1 ;;
        esac
        case "$name" in
            "") return 1 ;;
        esac

        # use Qogir as default, then try other icons
        local prefs="${EOS_ICON_SETS_PREFERENCE[@]/Qogir-dark/}"
        prefs="${EOS_ICON_SETS_PREFERENCE[@]/Qogir/}"

        for family in Qogir "${prefs[@]}"
        do
            family=${family##*/}
            icon="/usr/share/icons/$family/scalable/$type/$name.svg"
            if [ -e "$icon" ] ; then
                echo "$icon"
                return 0
            fi
        done
        return 1
    }

    icons() {
        find /usr/share/icons -name $1.\* 2> /dev/null | grep scalable | less -F
        # find /usr/share/icons -name $1.\* 2> /dev/null | less -F
    }

    git_kuulas() {
        # preparations for doing a git command

        case "$1" in
            push)
                case "$(realpath .)" in
                    /UNI/lisa/repo/*)  logstuff on ;;
                esac
                ;;
            pull)
                case "$(realpath .)" in
                    /UNI/lisa/repo/Manuel/b-assets) logstuff on ;;
                    # /UNI/lisa/repo/Manuel/eos) ;;
                esac
                ;;
            add)
                # if args include local PKGBUILD and
                # if local PKGBUILD includes some sums and
                # if local PKGBUILD is not the newest file
                # then try update checksums

                if [ -n "$(printf "%s\n" "$@" | grep "^PKGBUILD$")" ] ; then
                    if [ -r PKGBUILD ] && [ -w PKGBUILD ] && grep -P "^sha.*sums=|^md5sums=|^b2sums=" PKGBUILD >& /dev/null ; then
                        if [ "$($_TUTTU_SOVELLUSTEN_POLKU/ls -a1tr --ignore=. --ignore=.. | tail -n1)" != PKGBUILD ] ; then
                            read -p "Update checksums (Y/n)? " >&2
                            case "$REPLY" in
                                "" | [yY]*) updpkgsums ;;
                            esac
                        fi
                    fi
                fi
                ;;
        esac
        $_TUTTU_SOVELLUSTEN_POLKU/git "$@"
    }

    linktype() {
        local file="$1"
        local result=""

        [ -n "$file" ] || { echo "${FUNCNAME[0]}: give file parameter" >&2 ; return 1 ; }

        if [ -f "$file" ] ; then
            if [ -L "$file" ] ; then
                result="symlink"
            else
                case "$(stat -c %h "$file")" in
                    1) result="regular file" ;;
                    *) result="hardlink" ;;
                esac
            fi
        else
            result="not a regular file"
        fi
        echo "$result"
    }

    eos-man() {                                                        # 'man' extended for some external apps
        _man-eos-apps-info-helper() {
            local app=eos-apps-info-helper
            which $app &> /dev/null || return 1
            echo "==> $app $*" >&2
            $app "$@"
        }
        _man-plain-help() {
            if which "$1" &> /dev/null ; then
                read -p "Want to run '$* --help' (Y/n)? " >&2
                case "$REPLY" in
                    [Nn]*) return 0 ;;
                esac
                echo "==> $* --help:" >&2
                "$@" --help | less
                return $?
            else
                return 1
            fi
        }
        _man-get-item() {
            local arg
            for arg in "$@" ; do
                case "$arg" in
                    -*) ;;
                    *) echo "$arg"; return 0 ;;
                esac
            done
            echo "${FUNCNAME[1]}: parameters include no item for getting help" >&2
            return 1
        }

        local ret_man=0
        /usr/bin/man "$@"                                    # try normal man first
        ret_man=$?
        case "$ret_man" in
            16)
                local item="$(_man-get-item "$@")"
                if [ -n "$item" ] ; then
                    _man-eos-apps-info-helper "$item"                      # man failed, handle exit code 16 for unknown app
                    [ $? -eq 0 ] && return 0
                    _man-plain-help "$item"                                # eos-apps-info-helper failed, try 'command' --help
                    [ $? -eq 0 ] && return 0
                fi
                echo "$FUNCNAME: no manual page about '$item'." >&2
                ;;
        esac
        return $ret_man
    }
    manx() { man -H "$@" ; }

    my_prompt_command() {
        # Show one or two line prompt (folder, time) after trying to slightly shorten the folder name.

        local pwd=${PWD/$HOME/\~}             # shorten for $HOME
        local time="$(date +%a\ %H:%M.%S)"

        if [ -n "$HERE_ARROW" ] ; then
            local rarrow=')'
            local larrow='('
            local here="$HERE_ARROW"
        else
            local rarrow=$'\u2773'            # nice delimiters, https://en.wikipedia.org/wiki/Arrow_(symbol)#Unicode
            local larrow=$'\u2772'
            local here=$'\u2ba9'
        fi

        pwd="$larrow$pwd$rarrow"

        if [ ${#pwd} -gt $((COLUMNS / 2)) ] ; then
            printf -v PS1 "%s\n%s %s "  "$pwd" "$time" "$here"   # two line prompt
        else
            printf -v PS1 "%11s %s %s " "$time" "$pwd" "$here"   # one line prompt
        fi
    }

    if false ; then
        md() {
            # Usage: md name.md
            local file="$1"
            local usage="Usage: $FUNCNAME md-file"

            if [ -z "$file" ] ; then
                echo "$usage" >&2
                return 1
            fi

            # output with an md viewer
            local prog
            for prog in ghostwriter # vscodium code-oss code
            do
                if [ -x $_TUTTU_SOVELLUSTEN_POLKU/$prog ] ; then
                    echo "opening with ghostwriter..." >&2
                    $prog "$file"
                    return
                fi
            done

            # output viewer is a browser
            if [ -x $_TUTTU_SOVELLUSTEN_POLKU/pandoc ] ; then
                echo "converting with pandoc..." >&2
                local tmp="$(mktemp /tmp/tmp.$(basename "$file").XXXXX.html)"
                pandoc -f gfm -t html "$file" > "$tmp" || return 1
                if [ -r "$tmp" ] ; then
                    eos-open "file://$tmp"
                    sleep 5   # must wait because exo-open does not wait
                    rm -f "$tmp"
                fi
                return
            fi

            echo "$FUNCNAME: sorry, ghostwriter or pandoc is needed but not installed." >&2
            return 1
        }
    fi

    p() {
        local param=""
        [ -z "$1" ] && param="-Syu -d"
        pacman-ext $param "$@"
    }
    syu()  { p -${FUNCNAME^} ; }
    syyu() { p -${FUNCNAME^} ; }

    #pf() { pgrep -a "$@" ; } # list processes


    _Check_CDPATH_ARR() {  # CDPATH_ARR should contain unique folders
        local arrout=()
        local dir added

        for dir in "${CDPATH_ARR[@]}" ; do
            for added in "${arrout[@]}" ; do
                if [ "$dir" = "$added" ] ; then
                    echo "$FUNCNAME: warning: already added '$dir = $added'" >&2
                    continue 2
                fi
                if [ "$added" != "." ] && [ "$dir" != "." ] && [ "$dir" -ef "$added" ] ; then
                    echo "$FUNCNAME: warning: already added '$dir -ef $added'" >&2
                    continue 2
                fi
            done
            arrout+=("$dir")
        done
        # echo "orig = ${#CDPATH_ARR[@]}" >&2
        export CDPATH_ARR=("${arrout[@]}")
        # echo "new  = ${#CDPATH_ARR[@]}" >&2
    }
    _Check_CDPATH_ARR

    Unalias welcome
    welcome() {
        local arg welcome="eos-welcome --once"
        for arg in "$@" ; do
            case "$arg" in
                --installer)
                    $welcome "$@" &
                    return
                    ;;
            esac
        done
        setsid $welcome "$@"
    }

    xfce4-terminal() {
        $_TUTTU_SOVELLUSTEN_POLKU/xfce4-terminal --geometry=150x25 "$@"
    }

    # _set_terminal_title()       { printf "\e]2;%s\a" "$*" ; }
    _set_terminal_window_title()  { printf "\e]0;%s\a" "$*" ; }
    export -f _set_terminal_window_title   # _set_terminal_title

    MyTermTitle() {
        if true ; then
            local latest_user_command="$(history 1 | sed 's|^[ ]*[0-9]*[ ]*||')"
            if [ "$latest_user_command" != "$latest_user_command_previous" ] ; then
                latest_user_command_previous="$latest_user_command"
                _set_terminal_window_title "\"$latest_user_command\""
            fi
        else
            _set_terminal_window_title "${PWD/$HOME/\~}"
        fi
    }
    export -f MyTermTitle
    trap "MyTermTitle" DEBUG    # Set terminal title to currently running command:

    if [ -x $_TUTTU_SOVELLUSTEN_POLKU/grub-install ] ; then
        original-grub-install-parameters-f() {
            local out=$(sudo grep 'grub-install' /var/log/{Calamares,endeavour-install}.log 2>/dev/null)
            echo "$out" | sed -E -e 's|.*Running \(||' -e 's|"([^"]+)"[,)]*|\1|g' | head -n1
        }
        Alias original-grub-install-parameters original-grub-install-parameters-f
    fi

    forum() {
        local forum="https://forum.endeavouros.com"

        case "$1" in
            --latest | -n)      forum="$forum/latest" ;;
            --new)              forum="$forum/new" ;;
            --unread)           forum="$forum/unread" ;;
            --login | -l | "")  forum="$forum/login" ;;
            -h | --help)
                cat <<EOF >&2
Usage: $FUNCNAME [options]
Options:
    -h, --help         This help.
    -l, --login        Show the login page (default).
    -n, --latest       Show all latest posts.
    --new              Show the new posts page.
    --unread           Show the unread posts page.

Tips:
    <kbd>word</kbd>    Show the 'word' in a button like box.
EOF
                return 0
                ;;
            *)
                echo "sorry, parameter '$1' not supported." >&2
                $FUNCNAME -h
                return 1
                ;;
        esac
        firefox "$forum"
    }

    paccache() {
        # Changes to official paccache:
        # 1. check if sudo is needed
        # 2. be verbose always

        paccache-options() {
            local opts
            local sopts="a:c:dfhi:k:m:rquvVz"
            local lopts="dryrun,move:,remove,arch:,cachedir:,force,help,ignore:,keep:"
            lopts+=",min-atime:,min-mtime:,nocolor,quiet,uninstalled,verbose,version"

            opts="$(getopt -o=$sopts --longoptions $lopts --name "$progname" -- "$@")" || {
                #$FUNCNAME --help
                return 1
            }

            eval set -- "$opts"

            while true ; do
                case "$1" in
                    --dryrun | -d)      ;;
                    --move | -m)        sudo=sudo; shift ;;
                    --remove | -r)      sudo=sudo ;;
                    --arch | -a)        shift ;;
                    --cachedir | -c)    shift ;;
                    --force | -f)       ;;
                    --ignore | -i)      shift ;;
                    --keep | -k)        shift ;;
                    --min-atime)        shift ;;
                    --min-mtime)        shift ;;
                    --nocolor)          ;;
                    --null | -z)        ;;
                    --quiet | -q)       ;;
                    --uninstalled | -u) ;;
                    --verbose | -v)     verbose+=" $1" ;;
                    --version | -V)     ;;
                    --help | -h)        ;;

                    --) shift ; break ;;
                esac
                shift
            done
        }

        local progname="$FUNCNAME"
        local sudo=""
        local verbose="-v"

        paccache-options "$@" || return
        $sudo $_TUTTU_SOVELLUSTEN_POLKU/paccache $verbose "$@"
    }

    EmacsConfig() {
        [ -e ~/.emacs ] && return
        [ -x $_TUTTU_SOVELLUSTEN_POLKU/emacs ] || return

        echo "==> $FUNCNAME: configuring emacs" >&2

        cat <<EOF > ~/.emacs
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(c-guess-guessed-basic-offset 2 t)
 '(column-number-mode t)
 '(cua-mode t nil (cua-base))
 '(gdb-many-windows t)
 '(global-display-line-numbers-mode t)
 '(indent-tabs-mode nil)
 '(inhibit-startup-screen t)
 '(make-backup-files nil)
 '(next-line-add-newlines nil)
; '(package-selected-packages '(realgud))
 '(require-final-newline t)
 '(scroll-step 1)
 '(select-enable-clipboard t)
 '(tool-bar-mode nil)
 '(tool-bar-position 'right)
 '(vc-follow-symlinks t)
 '(x-select-enable-clipboard-manager nil)
)
EOF
        chown $LOGNAME:$LOGNAME ~/.emacs
    }
    EmacsConfig

    m-aur()                   { cd "${FUNCNAME[0]}" ; }
    m-m()                     { cd "${FUNCNAME[0]}" ; }
    m-more2()                 { cd "${FUNCNAME[0]}" ; }
    endeavouros()             { cd "${FUNCNAME[0]}" ; }
    endeavouros-testing-dev() { cd "${FUNCNAME[0]}" ; }

    command_not_found_handle() {
        if [ -f "$1" ] ; then
            eos-open "$@" 2>/dev/null
        elif [ -d "$1" ] ; then
            echo "==> $FUNCNAME: did you mean 'cd $*'?" >&2    # cd is not working here...
        else
            echo "==> $FUNCNAME: '$*' not recognized." >&2
        fi
    }

    [ -x $_TUTTU_SOVELLUSTEN_POLKU/chdirex ] && cd() { builtin cd "$($_TUTTU_SOVELLUSTEN_POLKU/chdirex "$@")" ; }


    upd() { sudo /bin/upd "$@" ; }
    
    sudofuncs fstrim mount umount powertop


    #############################################################
    # variables
    #############################################################

    [ -z "$FUNCNEST" ] && export FUNCNEST=100

    PROMPT_COMMAND=(my_prompt_command)

    export HISTCONTROL="erasedups"
    FIGNORE=".o:~"                      # ignored suffixes in filename completion

    CDPATH="${CDPATH_ARR[*]}"
    CDPATH="${CDPATH// /:}"
    export CDPATH

    #############################################################
    # aliases
    #############################################################

    [ $_COMMON_SETTINGS_VERBOSE = yes ] && echo "==> $FUNCNAME: aliases" >&2

    Alias bat                "bat --style=number"
    Alias pacman-branch      "pacman-conf --repo-list | grep '^testing$' || echo stable"
    Alias ci                 "ci -u"
    Alias cls                "clear"
    Alias curly              "curl --remote-name-all"
    Alias df                 "LANG=C df -hT"
    Alias eos-rankmirrors    "eos-rankmirrors --internal-testing"
    Alias history-del        "history -c && history -w"
    Alias history-select     "history | fzf --tac --no-separator --no-info"
    Alias hlp                "eos-man"
    Alias inxi               "inxi -z"
    Alias local-repo-manager "local-repo-manager --verbose"
    Alias ls                 "ls --color=auto -F"
    Alias nano               "nano -l"
    Alias o                  "eos-open --pref exo-open"
    Alias package-sizes      "expac -HM -Q '%m|%n' | column -t -s'|' | sort -nr | less"
                             # M is reasonable now, later G might be too
    Alias pp                 "p -j"
    Alias pacdiff            "eos-pacdiff"
    Alias paq                "sudo paq"
    Alias u                  "upd"

    AliasIf grub-mkconfig  update-grub  "sudo grub-mkconfig -o /boot/grub/grub.cfg"
    # AliasIf grub-mkconfig  grub.cfg     "update-grub"                                   # needed ???
    AliasIf meld-rcs       meld         "setsid meld-rcs"

    if true ; then
        Alias cp         "cp -i"
        Alias ln         "ln -i"
        Alias mv         "mv -i"
        Alias rm         "rm -i"
    fi

    _dispatch_my_cmd() {
        local cmd="$1"
        echo "==> $cmd" >&2
        sleep 2
        bash -c "$cmd"
    }

    #if type logstuff &> /dev/null ; then
    if [ -e $HOME/.config/hub.cpt ] ; then
        Reboot()   { _dispatch_my_cmd "logstuff off && sync && Power-routines -s reboot" ; }
        Poweroff() { _dispatch_my_cmd "logstuff off && sync && Power-routines -s poweroff" ; }
    else
        Reboot()   { _dispatch_my_cmd "sync && Power-routines -s reboot" ; }
        Poweroff() { _dispatch_my_cmd "sync && Power-routines -s poweroff" ; }
    fi
    Nap()          { _dispatch_my_cmd "sync && Power-routines -s suspend" ; }

    Alias ramsleep   Nap
    Alias bye        Poweroff
    Alias poweroff   Poweroff
    Alias reboot     Reboot
    Alias restart    Reboot

    #############################################################
    # bash completions
    #############################################################

    [ $_COMMON_SETTINGS_VERBOSE = yes ] && echo "==> $FUNCNAME: bash completions" >&2

    LoadCompletion() {
        local cmdname="$1"
        local compname="$2"
        local compfunc="$3"   # optional

        [ -r /usr/share/bash-completion/completions/$compname ] || return 1

        [ -n "$compfunc" ] || compfunc="_${compname}_"

        complete | grep "\-F" | grep " $cmdname$" >/dev/null || {
            # echo "loading $compfunc completion" >&2
            source /usr/share/bash-completion/completions/$compname
            complete -F $compfunc $cmdname
        }
    }

    #              new cmdname          pkgname     completion func
    LoadCompletion pacman-sudo-internal pacman      _pacman
    LoadCompletion p                    pacman-ext  _pacman-ext_

    [ -r ~/.dircolors ] && eval "$(dircolors ~/.dircolors)"

    RunSilentlyInBackground() {
        local app="$1"
        local firstpara="$2"
        shift

        echo "==> $app $@" >&2

        case "$firstpara" in 
            -h | --help*) $app "$@" 2> /dev/null ;;
            *)
                case "$app" in
                    kate)
                        HERE_ARROW=">" setsid $app "$@" &> /dev/null ;;   # workaround prompt for kate's integrated terminal!
                    *)
                                       setsid $app "$@" &> /dev/null ;;
                esac
        esac
    }

    qute() { setsid qtcreator -client "$@" &> /dev/null ; }

    AppsToFuncsMaker() {
        local apps=(
            adie                             # lightning fast editor
            # audacity
            # bluefish
            # chromium
            dolphin
            eog
            firefox
            firefox-developer-edition
            # geany
            # gedit
            ghostwriter
            gitk
            # gnome-boxes
            # gnome-builder
            kate
            # kdevelop
            konsole
            libreoffice
            # mousepad
            # notepadqq
            pamac-manager
            parole
            # "qtcreator -client"
            qterminal
            ristretto
            soffice
            terminator
            thunderbird
            xed
            xfce4-screenshooter
            xplayer
            xreader

            # eclipse
            # tkdiff
        )
        apps+=(        # here for other reasons!
            kaffeine
            # krusader
            # vivaldi-stable
        )

        if [ ${#apps[@]} -gt 0 ] ; then
            local pr pr1
            local tmpfile=$(mktemp)

            for pr in "${apps[@]}" ; do
                pr1=${pr%% *}
                Unalias $pr1
                which $pr1 &> /dev/null && echo "$pr1() { RunSilentlyInBackground $pr \"\$@\" ; }"
            done >> $tmpfile

            # shellcheck disable=SC1090
            source $tmpfile
            rm -f $tmpfile
        fi
    }
    AppsToFuncsMaker
    unset -f AppsToFuncsMaker

    [ -f ~/unison.log ] && rm -i ~/unison.log
}

bashrc() { # load updated bash settings
    case "$1" in
        --update)
            NextInfo2 "Updating settings ..."
            if WaitForConnection 10 ; then
                pushd $(dirname "$BASH_SOURCE") >/dev/null && git pull >/dev/null
                popd >/dev/null
                echo " done." >&2
                return
            else
                printf "\n==> Sorry, no internet connection, update failed.\n" >&2
            fi
            
            if false ; then
                for _ix in {1..10} ; do
                    if eos-connection-checker ; then
                        pushd $(dirname "$BASH_SOURCE") >/dev/null && git pull >/dev/null
                        popd >/dev/null
                        echo " done." >&2
                        return
                    fi
                    printf "."
                    sleep 1
                done
                printf "\n==> Sorry, no internet connection, update failed.\n" >&2
            fi
            ;;
        --plain)
            _COMMON_SETTINGS_VERBOSE=no           # common verbosity
            _COMMON_SETTINGS_VERBOSE_ALIAS=no     # verbosity specific to Alias()
            case "$1" in
                --verbose)       _COMMON_SETTINGS_VERBOSE=yes ;;
                --verbose-alias) _COMMON_SETTINGS_VERBOSE_ALIAS=yes ;;
            esac
            local cd_config="$HOME/.config/cd-extended.conf"
            if [ -f "$cd_config" ] && [ $(stat -c %s "$cd_config") -gt 0 ] ; then
                :
            else
                echo "Warning: file $cd_config is missing or empty, creating a skeleton." >&2
                if [ -n "$CODEDIR" ] ; then
                    cat <<EOF > "$cd_config"
CDPATH_ARR=(
    ~
    "$CODEDIR"
    "$CODEDIR"/*/_BUILD_
)
EOF
                else
                    echo "Warning: variable CODEDIR is not set!" >&2
                    cat <<EOF > "$cd_config"
CDPATH_ARR=(
    ~
)
EOF
                fi
            fi
            source "$cd_config"
            SettingsCommon
            ;;
        *)
            bashrc --update
            bashrc --plain
            echo "==> bash settings updated." >&2
            ;;
    esac
}

# Use current settings now. Update settings with 'bashrc'.
bashrc --plain
echo "==> 'bashrc' updates bash settings." >&2

if true ; then
    -() { builtin cd - ; }   # make plain - the same as "cd -"

    ..() {
        # cd to one of the parent folders, given number of levels (zero or more)
        # Examples:
        #    ..
        #    .. 5

        local levels="$1"
        local restore="-u"

        shopt extglob >/dev/null && restore="-s"

        case "$levels" in
            [0-9]*([0-9])) ;;    # Needs extglob! Note: emacs formatting fails miserably after this line...
            "") levels=1 ;;
            *)  echo "invalid number of levels: '$levels'" >&2
                return 1
                ;;
        esac
        shopt $restore extglob
        local -r dir=$(seq $levels | awk '{printf "../"}')
        builtin cd $dir
    }
fi
