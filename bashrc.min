#!/bin/bash

# Some convenient bash settings.

NextInfo2() { printf "==> %s" "$1" >&2 ; }  # shows info about the next operation (to stderr)

SettingsCommon()
{
    [ $_COMMON_SETTINGS_VERBOSE = yes ] && echo "==> $FUNCNAME" >&2
    case "$-" in
        *i*)
            # history commands with arrow keys (on an interactive shell)
            bind '"\e[A":history-search-backward'      # up arrow
            bind '"\e[B":history-search-forward'       # down arrow

            bind 'set show-all-if-ambiguous on'        # complete with single TAB
            bind 'set mark-symlinked-directories on'   # complete directory symlinks with slash
            ;;
    esac
    shopt -s autocd

    

    #############################################################
    # functions
    #############################################################

    Alias()
    {
        local name="$1"
        local def="$2"
        local force="$3"   # optional, values: "yes" "no" "", "" means "yes"
        local alias="builtin alias"

        [ "$force" = "" ] && force=yes

        if [ -n "$name" ] ; then
            if [ -n "$def" ] ; then
                if [ "$force" = "yes" ] ; then
                    $alias "$name"="$def"    # assign alias only if name is "free"
                    return
                fi
                local defold=$(LANG=C type "$name" 2>/dev/null | head -n1)
                if [ -z "$defold" ] ; then
                    $alias "$name"="$def"    # assign alias only if name is "free"
                    return
                fi
                [ $_COMMON_SETTINGS_VERBOSE_ALIAS = yes ] && echo "Warning: $FUNCNAME: Overriding old definition: '$defold'." >&2
            else
                $alias "$name"
            fi
        else
            $alias
        fi
    }
    AliasIf() {
        # make alias only if the app is available
        if type "$1" &>/dev/null ; then
            shift
            Alias "$@"
        else
            [ $_COMMON_SETTINGS_VERBOSE_ALIAS = yes ] && echo "==> $FUNCNAME: sorry, program '$1' not found" >&2
        fi
    }
    Unalias() { unalias "$1" 2>/dev/null ; }

    sou() { source ~/.bashrc "$@" ; }    # allow parameters to ~/.bashrc :)

    sudofuncs() {
        local tmpfile=$(mktemp)
        local name
        for name in "$@" ; do
            echo "$name() { sudo /usr/bin/$name \"\$@\" ; }" >> $tmpfile
        done
        source $tmpfile
        rm -f $tmpfile
    }


    Unalias type
    type() {
        # without parameters, show all aliases and functions
        case "$1" in
            "") { alias && declare -F ; } | less ;;
            *) builtin type -a "$@" ;;
        esac
    }

    -() { cd - ; }   # make plain - the same as "cd -"

    ..()
    {
        # cd to one of the parent folders, given number of levels (zero or more)
        # Example: .. 5

        local levels="$1"
        local -r levels_max=10000
        case "$levels" in
            "")
                levels=1
                ;;
            # [0-9] | [1-9]*([0-9]))     # assumes extglob is enabled! Note: emacs reformatting fails with this...
            #     ;;
            [0-9] | [1-9][0-9])
                if [ $levels -gt $levels_max ] ; then
                    echo "number of levels '$levels' must be less than $levels_max" >&2
                    return 1
                fi
                ;;
            *)
                echo "invalid number of levels: '$levels'" >&2
                return 1
                ;;
        esac
        local dir=$(seq $levels | awk '{printf "../"}')
        cd $dir
    }

    open-anything() { setsid exo-open "$@" 2>/dev/null ; }      # open any file (based on mime stuff)

    ncd() {
        case "$1" in
            --init)
                shopt -q cdable_vars && complete -v -F _cd -o nospace $FUNCNAME || complete -F _cd -o nospace $FUNCNAME
                ;;
            *)
                builtin cd "$(cd-extended "$@")"
                ;;
        esac
    }
    ncd --init

    ccat() { /bin/ccat "$@" | /bin/less -F ; }

    lsd()   { find . -type d -exec ls -ld {} \; ; }

    drw()   {
        # shellcheck disable=SC2010
        ls -l "$@" | grep rw
    }

    lp()  { l  "$@" | less -F ; }   # show long listing but no hidden dotfiles except "."
    llp() { ll "$@" | less -F ; }   # show long listing of all except ".."

    lsblk() {
        local width=300
        local lsblk="/usr/bin/lsblk -w$width"

        if [ -z "$1" ] ; then
            $lsblk -f -o+SIZE
        else
            $lsblk "$@"
        fi
    }

    shutdown()  { [ -z "$1" ] && Power-routines poweroff  || /bin/shutdown "$@" ; }

    BannerLine() {
        local len="$1"
        local str="$2"
        local newlines="$3"                      # ^ = newline to head, $ = newline to tail (~like in grep)

        if [ -z "$len" ] ; then
            len=$((COLUMNS / 2))
        elif [ -n "$(echo "$len" | tr -d '[0-9]')" ] ; then
            echo "$FUNCNAME: first parameter is not a number" >&2
            return 1
        fi
        case "$str" in
            "" | default) str="=" ;;
        esac

        case "$newlines" in
            "^" | "^$") echo "" ;;
        esac
        printf "%.0s$str" $(seq $len)
        case "$newlines" in
            "^$" | "$" | "") echo "" ;;
        esac
    }
    BannerLine2() { BannerLine "$@" >&2 ; }

    _DailyChecks_() {
        _SimpleUpdateCheck() {
            NextInfo2 "Checking updates ... "
            local updates
            updates=$(checkupdates)
            case "$?" in
                2)  echo "none." >&2 ;;
                0)
                   echo "done:" >&2

                   local header="Name|vNow|vNew|Description"                                # header item names
                   local header_ul=$(echo "$header" | sed 's/[^|]/~/g')                     # underlining the above
                   local _line

                   updates=$(echo "$updates" | sed 's/ -> / /' | tr ' ' '|')                # remove every " ->" and change every ' ' to '|'
                   updates=$(
                       echo "$updates" | \
                           while read _line ; do
                               echo "$_line" | sed "s/$/|$(expac -Q %d ${_line%%|*})/"      # append description to each line
                           done
                          )
                   updates="$(echo "$header"; echo "$header_ul"; echo "$updates")"          # add header
                   updates=$(echo "$updates" | column -t -s'|')                             # 'column' may change longest line length...
                   local maxlen=$(echo "$updates" | wc -L)                                  # find longest line length (for bannerline)
                   BannerLine $maxlen
                   echo "$updates"
                   BannerLine $maxlen
                   ;;
            esac
        }
        local daynr=$(date +%j)
        local daynrfile=$HOME/.daynr

        if [ "$daynr" != "$(cat $daynrfile 2>/dev/null)" ] ; then
            echo "$daynr" > $daynrfile

            _SimpleUpdateCheck | sed 's|^|    |'
        fi
    }
    _DailyChecks_

    man() {
        # simple man extension for some external apps

        local out
        local mancode=0

        out=$(/bin/man "$@" 2>&1)
        mancode=$?

        case "$mancode" in
            16) echo "==> eos-apps-info-helper $*" >&2
                eos-apps-info-helper "$@"
                ;;
            *)  echo "$out" | less -F >&2 ;;
        esac
    }

    my_prompt_command() {
        # Show two line prompt (folder, time) after trying to slightly shorten the folder name.

        local pwd=${PWD/$HOME/\~}                                         # shorten for $HOME

        if [ ${#pwd} -gt $((COLUMNS / 2)) ] ; then
            printf -v PS1 "{%s}\n%s> " "$pwd" "$(date +%a\ %H:%M.%S)"  # two line prompt
        else
            printf -v PS1 "%11s %s> " "$(date +%a\ %H:%M.%S)" "$pwd"   # one line prompt
        fi
    }

    md() {
        # Usage: md name.md
        local file="$1"
        local usage="Usage: $FUNCNAME md-file"

        if [ -z "$file" ] ; then
            echo "$usage" >&2
            return 1
        fi

        # output with an md viewer
        local prog
        for prog in ghostwriter # vscodium code-oss code
        do
            if [ -x /bin/$prog ] ; then
                echo "opening with ghostwriter..." >&2
                $prog "$file"
                return
            fi
        done

        # output viewer is a browser
        if [ -x /bin/pandoc ] ; then
            echo "converting with pandoc..." >&2
            local tmp="$(mktemp /tmp/tmp.$(basename "$file").XXXXX.html)"
            pandoc -f gfm -t html "$file" > "$tmp" || return 1
            if [ -r "$tmp" ] ; then
                exo-open "file://$tmp" &>/dev/null
                sleep 5   # must wait because exo-open does not
                rm -f "$tmp"
            fi
            return
        fi

        echo "$FUNCNAME: sorry, ghostwriter or pandoc is needed but not installed." >&2
        return 1
    }

    p() {
        local args=("$@")
        local basecmd="pacman-ext --extras --expac"
        case "$1" in
            "") args=(--no-banner -Syu) ;;
        esac
        $basecmd "${args[@]}"
    }

    sudofuncs fstrim mount umount


    #############################################################
    # variables
    #############################################################

    [ -z "$FUNCNEST" ] && export FUNCNEST=100

    PROMPT_COMMAND=(my_prompt_command)

    export HISTCONTROL="erasedups"
    FIGNORE=".o:~"                      # ignored suffixes in filename completion

    CDPATH="${CDPATH_ARR[*]}"
    CDPATH="${CDPATH// /:}"

    #############################################################
    # aliases
    #############################################################

    [ $_COMMON_SETTINGS_VERBOSE = yes ] && echo "==> $FUNCNAME: aliases" >&2

    Alias bat            "bat --style=number"
    Alias pacman-branch  "pacman-conf --repo-list | grep '^testing$' || echo stable"
    Alias ci             "ci -u"
    Alias cls            "clear"
    Alias curly          "curl --remote-name-all"
    Alias df             "LANG=C df -hT"
    Alias history-del    "history -c && history -w"
    Alias hlp            "eos-apps-info-helper"
    Alias inxi           "inxi -z"
    Alias ls             "ls --color=auto -F"
    Alias nano           "nano -l"
    Alias o              "open-anything"
    Alias pacdiff        "eos-pacdiff"
    #Alias p              "pacman-ext --extras --no-banner --expac"
    Alias paq            "sudo paq"
    Alias rc             "pkgcheck"
    Alias ramsleep       "Power-routines suspend"
    Alias welcome        "setsid eos-welcome --once"

    AliasIf grub-mkconfig update-grub "sudo grub-mkconfig -o /boot/grub/grub.cfg"
    AliasIf meld-rcs      meld        "meld-rcs"

    if true ; then
        Alias cp         "cp -i"
        Alias ln         "ln -i"
        Alias mv         "mv -i"
        Alias rm         "rm -i"
    fi

    if [ -n "$FORUM_MGR" ] && [ -n "$FORUM_DEFAULT" ] ; then
        Alias forum "$FORUM_MGR $FORUM_DEFAULT"
    fi

    if which logstuff &> /dev/null ; then
        Alias reboot    'logstuff off && sync && Power-routines reboot'
        Alias poweroff  'logstuff off && sync && Power-routines poweroff'
    else
        Alias reboot    "sync && reboot"
        Alias poweroff  "sync && poweroff"
    fi

    #############################################################
    # bash completions
    #############################################################

    [ $_COMMON_SETTINGS_VERBOSE = yes ] && echo "==> $FUNCNAME: bash completions" >&2

    LoadCompletion() {
        local cmdname="$1"
        local compname="$2"
        local compfunc="$3"   # optional

        [ -r /usr/share/bash-completion/completions/$compname ] || return 1

        [ -n "$compfunc" ] || compfunc="_${compname}_"

        complete | grep "\-F" | grep " $cmdname$" >/dev/null || {
            # echo "loading $compfunc completion" >&2
            source /usr/share/bash-completion/completions/$compname
            complete -F $compfunc $cmdname
        }
    }

    #              new cmdname          pkgname     completion func
    LoadCompletion pacman-sudo-internal pacman      _pacman
    LoadCompletion p                    pacman-ext  _pacman-ext_
    LoadCompletion rc                   pkgcheck    _pkgcheck_


    [ -r ~/.dircolors ] && eval "$(dircolors ~/.dircolors)"

    NiceFuncRun() {
        local app="$1"
        local firstpara="$2"
        shift

        if [ -x /bin/$app ]; then
            case "$firstpara" in 
                -h | --help*) /bin/$app "$@" 2> /dev/null ;;
                *)            setsid /bin/$app "$@" &> /dev/null ;;
            esac
        else
            command $app
        fi
    }

    AppsToFuncsMaker() {
        local apps=(
            adie                             # lightning fast editor
            # audacity
            # bluefish
            # chromium
            dolphin
            eog
            firefox
            firefox-developer-edition
            # geany
            # gedit
            ghostwriter
            gitk
            # gnome-boxes
            # gnome-builder
            kate
            # kdevelop
            konsole
            libreoffice
            # mousepad
            # notepadqq
            pamac-manager
            parole
            qterminal
            ristretto
            soffice
            terminator
            thunderbird
            xed
            xfce4-screenshooter
            xplayer
            xreader

            # eclipse
            # tkdiff
        )
        apps+=(        # here for other reasons!
            kaffeine
            # krusader
            # vivaldi-stable
        )

        if [ ${#apps[@]} -gt 0 ] ; then
            local pr
            local tmpfile=$(mktemp)

            for pr in "${apps[@]}" ; do
                Unalias $pr
                which $pr &> /dev/null && echo "$pr() { NiceFuncRun $pr \"\$@\" ; }"
            done >> $tmpfile

            # shellcheck disable=SC1090
            source $tmpfile
            rm -f $tmpfile
        fi
    }
    AppsToFuncsMaker
    unset -f AppsToFuncsMaker
}


case "$1" in
    --update)
        NextInfo2 "Updating settings ..."
        for _ix in {1..10} ; do
            if eos-connection-checker ; then
                pushd $(dirname "$BASH_SOURCE") >/dev/null && git pull >/dev/null
                popd >/dev/null
                echo " done." >&2
                return
            fi
            printf "."
            sleep 1
        done
        printf "\n==> Sorry, no internet connection, update failed.\n" >&2
        ;;
    *)
        _COMMON_SETTINGS_VERBOSE=no           # common verbosity
        _COMMON_SETTINGS_VERBOSE_ALIAS=no     # verbosity specific to Alias()

        case "$1" in
            --verbose)       _COMMON_SETTINGS_VERBOSE=yes ;;
            --verbose-alias) _COMMON_SETTINGS_VERBOSE_ALIAS=yes ;;
        esac

        source $HOME/.config/cd-extended.conf && SettingsCommon
        ;;
esac
